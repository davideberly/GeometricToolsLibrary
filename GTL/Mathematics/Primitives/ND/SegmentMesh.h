// Geometric Tools Library
// https://www.geometrictools.com
// Copyright (c) 2025 Geometric Tools LLC
// Distributed under the Boost Software License, Version 1.0
// https://www.boost.org/LICENSE_1_0.txt
// File Version: 2025.01.28

#pragma once

#include <GTL/Mathematics/Algebra/Vector.h>
#include <array>
#include <cstddef>
#include <cstdint>
#include <vector>

// The 'vertices' are a vertex pool that contain the vertices of the mesh. The
// 'indices' are index pairs into 'vertices', each pair representing a segment
// of the polysegment. The last constructor does not require that all elements
// of the vertex pool participate in the polysegment. The polysegment segments
// are unrestricted. They can form an open or closed polysegment. They can
// intersect at interior points of the segments. A segment can be degenerate
// whereby its endpoints are equal.

namespace gtl
{
    template <typename T, std::size_t N>
    class SegmentMesh
    {
    public:
        // The comments for topology are based on the input vertices having
        // L >= 2 elements ordered { V[0], V[1], ..., V[L-1] }.

        // Used by the default constructor to indicate the mesh is empty.
        static std::uint32_t constexpr TOPOLOGY_UNKNOWN = 0;

        // L must be an even number. The L/2 segments are
        // <V[0],V[1]>, <V[2],V[3]>, ..., <V[L-2],V[L-1]>.
        static std::uint32_t constexpr TOPOLOGY_DISJOINT = 1;

        // The vertices form an open polyline. The L-1 segments are
        // <V[0],V[1]>, <V[1],V[2]>, ..., <V[L-2],V[L-1]>.
        static std::uint32_t constexpr TOPOLOGY_CONTIGUOUS_OPEN = 2;

        // The vertices form a closed polyline. The L segments are
        // <V[0],V[1]>, ..., <V[L-2],V[L-1]>, <V[L-1],V[0]>.
        static std::uint32_t constexpr TOPOLOGY_CONTIGUOUS_CLOSED = 3;

        // The segments are generated by indexing into the vertex array.
        // The mesh has M segments, each segment generated by an index
        // pair S[i] for 0 <= i <= M-1. The segments are
        // <V[S[0][0],S[0][1]>, <V[S[1][0],S[1][1]>, ...,
        // <V[S[M-1][0],S[M-1][1]>. The other topologies can be
        // represented using the indexed approach,
        //   DISJOINT: S[i] = {2*i, 2*i+1} for 0 <= i <= (L-2)/2
        //   CONTIGUOUS_OPEN: S[i] = {i, i + 1} for 0 <= i <= L-2
        //   CONTIGUOUS_CLOSED: S[i] = {i, (i + 1) % L} for 0 <= i <= L-1
        static std::uint32_t constexpr TOPOLOGY_INDEXED = 4;

        SegmentMesh()
            :
            mTopology(TOPOLOGY_UNKNOWN),
            mVertices{},
            mIndices{}
        {
        }

        // Create a mesh with DISJOINT topology.
        SegmentMesh(std::vector<Vector<T, N>> const& vertices)
            :
            mTopology(TOPOLOGY_DISJOINT),
            mVertices(vertices),
            mIndices{}
        {
            GTL_ARGUMENT_ASSERT(
                vertices.size() >= 2 &&
                (vertices.size() & static_cast<std::size_t>(1)) == 0,
                "Invalid number of vertices.");

            mIndices.resize(vertices.size() / 2);
            for (std::size_t i = 0; i < mIndices.size(); ++i)
            {
                mIndices[i][0] = 2 * i;
                mIndices[i][1] = mIndices[i][0] + 1;
            }
        }

        // Create a mesh with CONTIGUOUS topology. Set isOpen to 'true' for
        // CONTIGUOUS_OPEN topology or 'false' for CONTIGUOUS_CLOSED
        // topology.
        SegmentMesh(std::vector<Vector<T, N>> const& vertices, bool isOpen)
            :
            mTopology(TOPOLOGY_UNKNOWN),
            mVertices(vertices),
            mIndices{}
        {
            GTL_ARGUMENT_ASSERT(
                vertices.size() >= 2,
                "Invalid number of vertices.");

            if (isOpen)
            {
                mTopology = TOPOLOGY_CONTIGUOUS_OPEN;
                mIndices.resize(vertices.size() - 1);
                for (std::size_t i0 = 0, i1 = 1; i0 < mIndices.size(); i0 = i1++)
                {
                    mIndices[i0][0] = i0;
                    mIndices[i0][1] = i1;
                }
            }
            else
            {
                mTopology = TOPOLOGY_CONTIGUOUS_CLOSED;
                mIndices.resize(vertices.size());
                for (std::size_t i0 = mIndices.size() - 1, i1 = 0; i1 < mIndices.size(); i0 = i1++)
                {
                    mIndices[i1][0] = i0;
                    mIndices[i1][1] = i1;
                }
            }
        }

        // Create a mesh with INDEXED topology. If the caller is certain that
        // the indices satisfy indices[i] < vertices.size() for all i, set
        // validateIndices to 'false'. Otherwise, set validateIndices to 'true'
        // so that the vertices are validated internally.
        SegmentMesh(std::vector<Vector<T, N>> const& vertices,
            std::vector<std::array<std::size_t, 2>> indices, bool validateIndices)
            :
            mTopology(TOPOLOGY_INDEXED),
            mVertices(vertices),
            mIndices(indices)
        {
            GTL_ARGUMENT_ASSERT(
                vertices.size() >= 2 && indices.size() >= 1,
                "Invalid number of vertices or indices.");

            if (validateIndices)
            {
                for (std::size_t i = 0; i < indices.size(); ++i)
                {
                    GTL_ARGUMENT_ASSERT(
                        indices[i][0] < vertices.size() && indices[i][1] < vertices.size(),
                        "Invalid index into vertex array.");
                }
            }
        }

        // Member access. For now the vertices and indices are read-only.
        // TODO: Allow for dynamic creation of meshes. This requires a
        // redesign that should also be used for implementing a similar class
        // for triangle mesh primitives.
        std::uint32_t GetTopology() const
        {
            return mTopology;
        }

        std::vector<Vector<T, N>> const& GetVertices() const
        {
            return mVertices;
        }

        std::vector<std::array<std::size_t, 2>> const& GetIndices() const
        {
            return mIndices;
        }

    private:
        std::uint32_t mTopology;
        std::vector<Vector<T, N>> mVertices;
        std::vector<std::array<std::size_t, 2>> mIndices;
    };

    // Comparisons to support sorted containers.
    template <typename T, std::size_t N>
    bool operator==(SegmentMesh<T, N> const& mesh0, SegmentMesh<T, N> const& mesh1)
    {
        return mesh0.GetTopology() == mesh1.GetTopology()
            && mesh0.GetVertices() == mesh1.GetVertices()
            && mesh0.GetIndices() == mesh1.GetIndices();
    }

    template <typename T, std::size_t N>
    bool operator!=(SegmentMesh<T, N> const& mesh0, SegmentMesh<T, N> const& mesh1)
    {
        return !operator==(mesh0, mesh1);
    }

    template <typename T, std::size_t N>
    bool operator<(SegmentMesh<T, N> const& mesh0, SegmentMesh<T, N> const& mesh1)
    {
        if (mesh0.GetTopology() < mesh1.GetTopology())
        {
            return true;
        }

        if (mesh0.GetTopology() > mesh1.GetTopology())
        {
            return false;
        }

        if (mesh0.GetVertices() < mesh1.GetVertices())
        {
            return true;
        }

        if (mesh0.GetVertices() > mesh1.GetVertices())
        {
            return false;
        }

        return mesh0.GetIndices() < mesh1.GetIndices();
    }

    template <typename T, std::size_t N>
    bool operator<=(SegmentMesh<T, N> const& mesh0, SegmentMesh<T, N> const& mesh1)
    {
        return !operator<(mesh1, mesh0);
    }

    template <typename T, std::size_t N>
    bool operator>(SegmentMesh<T, N> const& mesh0, SegmentMesh<T, N> const& mesh1)
    {
        return operator<(mesh1, mesh0);
    }

    template <typename T, std::size_t N>
    bool operator>=(SegmentMesh<T, N> const& mesh0, SegmentMesh<T, N> const& mesh1)
    {
        return !operator<(mesh0, mesh1);
    }

    // Template aliases for convenience.
    template <typename T> using SegmentMesh2 = SegmentMesh<T, 2>;
    template <typename T> using SegmentMesh3 = SegmentMesh<T, 3>;
}
