// Geometric Tools Library
// https://www.geometrictools.com
// Copyright (c) 2025 Geometric Tools LLC
// Distributed under the Boost Software License, Version 1.0
// https://www.boost.org/LICENSE_1_0.txt
// File Version: 0.0.2025.10.21

#pragma once

// MassSpringArbitrary represents a set of M masses that are connected by
// S springs with arbitrary topology. The function SetSpring(...) should
// be called for each spring that you want in the system.

#include <GTL/Mathematics/Physics/ParticleSystem.h>
#include <cstddef>
#include <set>
#include <vector>

namespace gtl
{
    template <typename T, std::size_t N>
    class MassSpringArbitrary : public ParticleSystem<T, N>
    {
    public:
        virtual ~MassSpringArbitrary() = default;

        MassSpringArbitrary(std::size_t numParticles, std::size_t numSprings, T const& step)
            :
            ParticleSystem<T, N>(numParticles, step),
            mSpring(numSprings, Spring{}),
            mAdjacent(numParticles)
        {
        }

        struct Spring
        {
            Spring()
                :
                particle0(0),
                particle1(0),
                constant(C_<T>(0)),
                length(C_<T>(0))
            {
            }

            std::size_t particle0, particle1;
            T constant, length;
        };

        // Member access.
        inline std::size_t GetNumSprings() const
        {
            return mSpring.size();
        }

        void SetSpring(std::size_t index, Spring const& spring)
        {
            mSpring[index] = spring;
            mAdjacent[spring.particle0].insert(index);
            mAdjacent[spring.particle1].insert(index);
        }

        inline Spring const& GetSpring(std::size_t index) const
        {
            return mSpring[index];
        }

        // The default external force is zero. Derive a class from this one
        // to provide nonzero external forces such as gravity, wind, friction,
        // and so on. This function is called by Acceleration(...) to compute
        // the impulse F/m generated by the external force F.
        virtual Vector<T, N> ExternalAcceleration(std::size_t, T const&,
            std::vector<Vector<T, N>> const&,
            std::vector<Vector<T, N>> const&)
        {
            return Vector<T, N>::Zero();
        }

    protected:
        // Callback for acceleration (ODE solver uses x" = F/m) applied to
        // particle i. The positions and velocities are not necessarily
        // mPosition and mVelocity, because the ODE solver evaluates the
        // impulse function at intermediate positions.
        virtual Vector<T, N> Acceleration(std::size_t i, T const& time,
            std::vector<Vector<T, N>> const& position,
            std::vector<Vector<T, N>> const& velocity)
        {
            // Compute spring forces on position X[i]. The positions are not
            // necessarily mPosition, because the RK4 solver in ParticleSystem
            // evaluates the acceleration function at intermediate positions.

            Vector<T, N> acceleration = ExternalAcceleration(i, time, position, velocity);

            for (auto adj : mAdjacent[i])
            {
                // Process a spring connected to particle i.
                Spring const& spring = mSpring[adj];
                Vector<T, N> diff{};
                if (i != spring.particle0)
                {
                    diff = position[spring.particle0] - position[i];
                }
                else
                {
                    diff = position[spring.particle1] - position[i];
                }

                T ratio = spring.length / Length(diff);
                Vector<T, N> force = spring.constant * (C_<T>(1) - ratio) * diff;
                acceleration += this->mInvMass[i] * force;
            }

            return acceleration;
        }

        std::vector<Spring> mSpring;

        // Each particle has an associated array of spring indices for those
        // springs adjacent to the particle. The set elements are spring
        // indices, not indices of adjacent particles.
        std::vector<std::set<std::size_t>> mAdjacent;

    private:
        friend class UnitTestMassSpringArbitrary;
    };
}
