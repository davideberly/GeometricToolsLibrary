// Geometric Tools Library
// https://www.geometrictools.com
// Copyright (c) 2025 Geometric Tools LLC
// Distributed under the Boost Software License, Version 1.0
// https://www.boost.org/LICENSE_1_0.txt
// File Version: 0.0.2025.10.15

#pragma once

// MassSpringCurve represents a set of N-1 springs connecting N masses that
// lie on a curve.

#include <GTL/Mathematics/Physics/ParticleSystem.h>
#include <cstddef>
#include <vector>

namespace gtl
{
    template <typename T, std::size_t N>
    class MassSpringCurve : public ParticleSystem<T, N>
    {
    public:
        virtual ~MassSpringCurve() = default;

        MassSpringCurve(std::size_t numParticles, T const& step)
            :
            ParticleSystem<T, N>(numParticles, step),
            mConstant(numParticles - 1, C_<T>(0)),
            mLength(numParticles - 1, C_<T>(0))
        {
        }

        // Member access. The parameters are spring constant and spring
        // resting length.
        inline std::size_t GetNumSprings() const
        {
            return this->mNumParticles - 1;
        }

        inline void SetConstant(std::size_t i, T const& constant)
        {
            mConstant[i] = constant;
        }

        inline void SetLength(std::size_t i, T const& length)
        {
            mLength[i] = length;
        }

        inline T const& GetConstant(std::size_t i) const
        {
            return mConstant[i];
        }

        inline T const& GetLength(std::size_t i) const
        {
            return mLength[i];
        }

        // The default external force is zero. Derive a class from this one
        // to provide nonzero external forces such as gravity, wind, friction
        // and so on. This function is called by Acceleration(...) to compute
        // the impulse F/m generated by the external force F.
        virtual Vector<T, N> ExternalAcceleration(std::size_t, T const&,
            std::vector<Vector<T, N>> const&,
            std::vector<Vector<T, N>> const&)
        {
            return Vector<T, N>::Zero();
        }

    protected:
        // Callback for acceleration (ODE solver uses x" = F/m) applied to
        // particle i. The positions and velocities are not necessarily
        // mPosition and mVelocity, because the ODE solver evaluates the
        // impulse function at intermediate positions.
        virtual Vector<T, N> Acceleration(std::size_t i, T const& time,
            std::vector<Vector<T, N>> const& position,
            std::vector<Vector<T, N>> const& velocity)
        {
            // Compute spring forces on position X[i].  The positions are not
            // necessarily mPosition, because the RK4 solver in ParticleSystem
            // evaluates the acceleration function at intermediate positions.
            // The endpoints of the curve of masses must be handled
            // separately, because each has only one spring attached to it.

            Vector<T, N> acceleration = ExternalAcceleration(i, time, position, velocity);
            Vector<T, N> diff{}, force{};
            T ratio{};

            if (i > 0)
            {
                std::size_t iM1 = i - 1;
                diff = position[iM1] - position[i];
                ratio = mLength[iM1] / Length(diff);
                force = mConstant[iM1] * (C_<T>(1) - ratio) * diff;
                acceleration += this->mInvMass[i] * force;
            }

            std::size_t iP1 = i + 1;
            if (iP1 < this->mNumParticles)
            {
                diff = position[iP1] - position[i];
                ratio = mLength[i] / Length(diff);
                force = mConstant[i] * (C_<T>(1) - ratio) * diff;
                acceleration += this->mInvMass[i] * force;
            }

            return acceleration;
        }

        std::vector<T> mConstant, mLength;

    private:
        friend class UnitTestMassSpringCurve;
    };
}
